////////////////////////////////////////////////////////////////////////////////
// Filename: light.ps
////////////////////////////////////////////////////////////////////////////////

#include "common.vs"
#include "CommonLight.ps"

/////////////
// GLOBALS //
/////////////
Texture2D g_texAlbedo : register(t0);
Texture2D g_texNormal : register(t1);


//////////////
// TYPEDEFS //
//////////////
struct PixelInputType
{
    float4 position : SV_POSITION;
    float2 tex : TEXCOORD0;
    float3 normal : NORMAL;
	float3 tangent : TANGENT0;
	float3 binormal : BINORMAL0;
	float3 worldPosition : TEXCOORD1;
};

////////////////////////////////////////////////////////////////////////////////
// Pixel Shader
////////////////////////////////////////////////////////////////////////////////
float4 main(PixelInputType input) : SV_TARGET
{
	//return float4( cb_lightCount, 0.0, 0.0, 0.0 );
	
	float4 FinalLight = (float4)0;
	
	float3 v = normalize( cb_cameraPosition - input.worldPosition );
	
    // Sample the pixel color from the texture using the sampler at this texture coordinate location.
    float4 albedo = g_texAlbedo.Sample( g_SamplerLinearWrap, input.tex );
	
	float3 n = normalize( input.normal );
	
	[loop]
    for( int i = 0; i < cb_lightCount; i++ )
	{
		float3 l;
		float fade;
		
		LightParam light = sb_lightVector[i];
		
		if( light.type == 0 )
		{
			l = normalize( light.lightPos );
			fade = 1.0;
		}
		else
		{
			l = ( light.lightPos - input.worldPosition );
			float dist = length( l );
			l = normalize( l );
			fade = 1.0 / ( dist * dist );			
		}	
		
		if( fade < 0.0001 )
			continue;
		
		float3 h = normalize( l + v );		
		float spec = max( 0.0, D_BlinnPhong( 0.2, dot( n, h ) ) );
		float3 diffuse = ( max( dot( n, l ), 0.0f ) / PI );
		FinalLight.rgb += saturate( diffuse  * light.lightColor + spec );
		
	}	
	
	FinalLight.rgb = ( FinalLight.rgb ) * albedo.rgb;
	
	FinalLight.a = 1.0f;
	#ifdef TEST
		FinalLight.rgb = 1.0f;
	#endif
	
	return FinalLight;
}