
#include "samplers.sh"
static const float PI = 3.14159265f;

struct LightParam
{
	float3 lightPos; 
	int type;
	float3 lightDir;
	float angle;
	float3 lightColor;
	float attenuation;
};

StructuredBuffer<LightParam> sb_lightVector: register(t15);

//функция расчета затухания для источника света
float GetAttenuation( float distance, float lightInnerR, float invLightOuterR )
{
    //float d = max( distance, lightInnerR);
    //return saturate(1.0 - pow(d * invLightOuterR, 4.0)) / (d * d + 1.0);
	return saturate(1.0 - pow(distance * invLightOuterR, 4.0)) / (distance * distance + 1.0);
}

float D_BlinnPhong( float roughness, float NdotH )
{
   float a = max( 0.001f, roughness * roughness );
   return ( 1.0f / (PI * a * a) ) * pow( NdotH, 2.0f / (a * a) - 2.0f );
}


float specByPhong( float3 N, float3 L, float3 V, float roughness) 
{
  float3 H = normalize(L + V);
  
  float NdotL    = max( dot( N, L ), 0.0 );
  float NdotV    = max( dot( N, V ), 0.0 );
  float NdotH    = max( dot( N, H ), 1.0e-7 );
  float VdotH    = max( dot( V, H ), 0.0 );
  float LdotV    = max( dot( L, V ), 0.0 );
  
  //float r0 = lerp(0.004,0.7,specular);
  float r = roughness;
  
  float D = 1;
  
  D = D_BlinnPhong(r, NdotH);
  //D = D_Skyforge(r, NdotH);
  //D = D_Beckmann(r, NdotH);
  //D = D_GGX(r, NdotH);
  
  //float G = 1;
  //G = G_Implicit(NdotV, NdotL);
  //G = G_CookTorrance(NdotV, NdotL, NdotH, VdotH);
  //G = G_Kelemen(NdotV, NdotL, LdotV);
  //G = G_Smith(r, NdotV, NdotL);

  
  //float F = 1;
  //F = F_Schlick(r0,      VdotH);
  //F = F_CookTorrance(r0, VdotH);
  
  return max( D/( 4.0 * NdotL * NdotV ), 0.0 );
}

